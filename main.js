/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagSearchPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

var TagSearchPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.addCommand({
      id: "open-tag-search",
      name: "Open tag search",
      callback: () => {
        const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
        const search = searchPlugin && searchPlugin.instance;
        if (searchPlugin && searchPlugin.instance) {
          new TagSearchModal(this.app, search).open();
        } else {
          new import_obsidian.Notice("Please enable the search core plugin!");
        }
      }
    });
  }
  onunload() {
  }
};

var TagSearchModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app2, search) {
    super(app2);
    this.app = app2;
    this.search = search;
  }

  onOpen() {
    super.onOpen();
    this.inputEl.addEventListener("keydown", (ev) => {
      this.maybeChooseFirstSuggestion(ev);
    });
  }

  onClose() {
    super.onClose();
    this.inputEl.removeEventListener("keydown", (ev) => {
    });
  }

  getItems() {
    const files = app.vault.getMarkdownFiles();
    const counts = /* @__PURE__ */ new Map();
    for (const file of files) {
      const cache = app.metadataCache.getCache(file.path);
      if (cache === null) {
        continue;
      }
      const tags = (0, import_obsidian.getAllTags)(cache) || [];
      tags.forEach((tag) => {
        counts.set(tag, (counts.get(tag) || 0) + 1);
      });
    }
    // Sort tags by frequency descending
    return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]).map((e) => e[0]);
  }

  getItemText(item) {
    return item;
  }

  onChooseItem(item, evt) {
    // New behavior:
    // 1) If a tag note exists (its frontmatter aliases include the tag string or its non-# form), open that note.
    // 2) Otherwise, open a new modal listing all notes that contain the tag and let the user pick one to open.
    const tag = item; // item includes leading '#', e.g. '#tag'
    const tagNoHash = tag.startsWith("#") ? tag.slice(1) : tag;

    const files = app.vault.getMarkdownFiles();

    // 1) Search for a tag note by looking for a frontmatter alias that matches tag or tag without '#'
    for (const file of files) {
      const cache = app.metadataCache.getCache(file.path);
      if (!cache)
        continue;
      const fm = cache.frontmatter;
      if (fm && fm.aliases) {
        let aliases = fm.aliases;
        if (!Array.isArray(aliases)) {
          aliases = [aliases];
        }
        for (const a of aliases) {
          if (a === tag || a === tagNoHash || a === "#" + tagNoHash) {
            this.app.workspace.getLeaf().openFile(file);
            this.close();
            return;
          }
        }
      }
    }

    const matched = [];
    for (const file of files) {
      const cache = app.metadataCache.getCache(file.path);
      if (!cache)
        continue;
      const tags = (0, import_obsidian.getAllTags)(cache) || [];
      if (tags.includes(tag)) {
        matched.push(file);
      }
    }

    if (matched.length === 0) {
      new import_obsidian.Notice(`No notes contain ${tag}`);
      this.close();
      return;
    }

    if (matched.length === 1) {
      this.app.workspace.getLeaf().openFile(matched[0]);
      this.close();
      return;
    }

    const pluginApp = this.app;
    class TagFileChooser extends import_obsidian.FuzzySuggestModal {
      constructor(app2, files2, searchInstance, tagString) {
        super(app2);
        this.files = files2;
        this.searchInstance = searchInstance;
        this.tagString = tagString;
      }

      onOpen() {
        super.onOpen();
        const inputParent = this.inputEl.parentElement;
        const btn = document.createElement("button");
        btn.textContent = "ðŸ”";
        btn.title = "å¡«å…¥å…¨å±€æœç´¢";
        btn.setAttribute("aria-label", "å¡«å…¥å…¨å±€æœç´¢");
        btn.className = "tag-search-insert-btn";
        btn.style.marginRight = "6px";
        btn.style.padding = "0 8px";
        btn.style.fontSize = "14px";
        btn.style.display = "inline-flex";
        btn.style.alignItems = "center";
        btn.style.justifyContent = "center";
        btn.style.border = "none";
        btn.style.background = "transparent";
        btn.style.cursor = "pointer";
        try {
          const inputRect = this.inputEl.getBoundingClientRect ? this.inputEl.getBoundingClientRect() : null;
          if (inputRect && inputRect.height) {
            btn.style.height = inputRect.height + "px";
            btn.style.lineHeight = inputRect.height + "px";
          } else {
            btn.style.height = "28px";
            btn.style.lineHeight = "28px";
          }
        } catch (e) {
          btn.style.height = "28px";
          btn.style.lineHeight = "28px";
        }
        btn.addEventListener("click", (e) => {
          const defaultTagSearchString = `tag:${this.tagString}`;
          if (this.searchInstance && this.searchInstance.openGlobalSearch) {
            this.searchInstance.openGlobalSearch(defaultTagSearchString);
          } else {
            new import_obsidian.Notice("Global Search æœªå¯ç”¨æˆ–ä¸å¯ç”¨");
          }
          this.close();
        });
        if (inputParent) {
          inputParent.insertBefore(btn, this.inputEl);
        }
        try {
          this.inputEl.focus();
        } catch (e) {
        }
        setTimeout(() => {
          try {
            const inputRect2 = this.inputEl.getBoundingClientRect ? this.inputEl.getBoundingClientRect() : null;
            if (inputRect2 && inputRect2.height) {
              btn.style.height = inputRect2.height + "px";
              btn.style.lineHeight = inputRect2.height + "px";
            }
            this.inputEl.focus();
          } catch (e) {
          }
        }, 50);
      }

      onClose() {
        super.onClose();
        const btn = this.contentEl.querySelector('.tag-search-insert-btn');
        if (btn) {
          btn.remove();
        }
      }

      getItems() {
        return this.files;
      }

      getItemText(file) {
        return file.path;
      }

      onChooseItem(file, evt2) {
        pluginApp.workspace.getLeaf().openFile(file);
        this.close();
      }
    }

    this.close();
    new TagFileChooser(this.app, matched, this.search, tag).open();
  }

  maybeChooseFirstSuggestion(evt) {
    var _a, _b;
    const toggle = evt.ctrlKey || evt.metaKey;
    const negate = evt.shiftKey;
    if (evt.key === "Enter" && (toggle || negate)) {
      const choice = (_b = (_a = this.resultContainerEl.getElementsByClassName("is-selected").item(0)) == null ? void 0 : _a.textContent) != null ? _b : null;
      if (choice != null) {
        this.close();
        this.onChooseItem(choice, evt);
      }
    }
  }
};
